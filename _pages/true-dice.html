---
layout: portfolio
title: VR App for Dice simulation
section: Portfolio
repo: Dante-666/TrueDice
---
<!-- portfolio -->
<section class="section">
  <div class="container">
    <div class="col-lg-4 col-sm-6 mb-4" style="margin:auto">
      <article class="card shadow">
	<div class="card-body">
	  {% for repository in site.github.public_repositories %}
	    {% if repository.full_name == page.repo %}
	    <h4 class="card-title">
	      <a class="text-dark" href="{{ repository.html_url }}">{{repository.name}}</a>
	    </h4>
	    <p class="card-text">{{ repository.description }}</p>
	  {% endif %}
	  {% endfor %}
	</div>
      </article>
    </div>
    <div class="row">
      <section class="subsection">
	<h3>Introduction</h3>
	<p>
	I played this classic Indian board game 
	<a class="text-dark" href="https://en.wikipedia.org/wiki/Ludo_(board_game)">Ludo</a>
	with my nephew and niece and complained about losing the die too often. This inspired me 
	to create a virtual dice that the user can physically manipulate and it won't be based on 
	some pseudorandom number generation but as close to true randomness that one can achieve. 
	As research, I looked up some apps on Google Play Store and found none of them do what I 
	wanted. Some implementations just applied an impulse force to the die/dice in the scene
       	and they jumped and gave a number. Some others employed animation and pseudorandom 
	number generation to show the particular face.</p>
	<img src="assets/images/portfolio/truedice/ludo.png" alt="Ludo board game" 
	class="img-fluid rounded d-block" style="margin-bottom:3rem;margin-top:3rem;">
	<p>
	These apps were not good enough and as I pondered more about the idea, I thought, why 
	hasn't anyone done this yet? An Android phone has an accelerometer sensor with fusion 
	algorithms that combines data from multiple sources to filter out the data. We can 
	figure out the forces being applied to the mobile and use relativistic frames of 
	reference to manipulate the die. We also have physics and collision detection, which 
	can contain the die within an enclosed space. It's just a matter of putting everything 
	together.
	</p>
      </section>
    </div>
    <div class="row">
      <section class="subsection">
	<h3>Methodology</h3>
	<p>Now that I had the basic layout ready, I had to find the right ingredients to 
	make it work. I had to find a lightweight game engine that runs on Android and possibly 
	supports other platforms. Depending on my skillset, I looked for a C++-based game engine
	and came across
	<a class="text-dark" href="https://www.cocos.com/en/cocos2dx">Cocos2dx</a>. 
	It is open-source, comes with 2D/3D physics integration, 
	multimedia support, and a ton of other game-ready features like networking. It can 
	deploy on Android, iOS, Linux, Mac OSX and Windows platforms, which is just what I 
	needed. There is 
	<a class="text-dark" href="https://www.cocos.com/en/cocos2dx">Cocos Creator</a>
	as well, which is more like Unity and has a graphical 
	interface and script-based development system. But I don't particularly appreciate 
	using those and I'll illustrate why later.</p>
	<h5>add a basic image of mobile + bounding box</h5>
	<p>Let's imagine that you are holding a transparent cuboid, a bounding box that 
	contains a die. If we shake the cuboid and introduce acceleration, the die will not 
	experience any force until it hits the cuboid walls and then proceeds to bounce off 
	in a random direction. Another way to see this is to attach a camera to one of the cuboid 
	faces and observe the die's motion. It will look as if an opposite force, with respect 
	to the bounding box, is being applied to the die and this is the essential crux of this 
	app/game. Of course, we will cheat a lot here and not model things precisely because we
	don't have to. Simple approximations do the trick just fine and can be parameterized 
	well enough.
	</p>
      </section>
    </div>
    <div class="row">
      <section class="subsection">
	<h3>Ingredients</h3>
	<p>I'll componentize the entire app into atomic elements, which will help us achieve 
	the big picture. Itemization helps with the planning and timely execution of the whole 
	project. One can prioritize the items and build them independently of other units and 
	submit a piece of code or model so that the game can slowly take shape.
	</p>
	<img src="assets/images/portfolio/truedice/puzzle.png" alt="Jigsaw" 
	class="img-fluid rounded d-block" style="margin-bottom:3rem;margin-top:3rem">
	<p>The game has a scene graph to which objects are attached. Here, we need a static floor 
	surrounded by invisible walls and a dynamic die object. And the GUI objects for insertion, 
	changing the color of the die, adding SFX and particle effects.</p>
	<h4>Game Objects<h5>
	<ul>
	  <li>
	    <section>
	      <h5>Dice</h5>
	      <p>It is a cube primitive from the point of view of the physics engine. We can add a 
	      more refined and realistic-looking low-poly mesh, but collision detection will be 
	      performed by modeling a cube. I designed the object file in blender by differencing 
	      a low-poly icosphere with a cube. It chips away and rounds the corners. I edited the 
	      mesh further and beveled the edges to make it look even more natural. Since the mesh 
	      became more complicated, I used the Smart UV Unwrap to generate a guide for texture 
	      mapping and used Inkscape to add white dots and transparency to the texture. Why we 
	      add transparency would become apparent when we discuss shaders.
	      </p>
	    </section>
	  </li>
	  <li>
	    <section>
	      <h5>Floor</h5>
	      <p>A simple quad or two triangles can model this. We can even write the mesh down 
	      ourselves and make counter-clockwise face assignments to be rendered as a front face. 
	      This object is the best sample to illustrate and learn about UV Mapping and its 
	      working. Two extreme corners should be assigned the UV coordinates (0, 0) and (1, 1) 
	      and when the quad is drawn, we should see the entire image drawn onto the quad.
	      </p>
	      <p> We can use a large image with a high memory footprint to add the texture or go 
	      with a seamless/repeating texture that 
	      $$I(x+N*1, y+M*1) = I(x, y); \{0 \leq x, y \leq 1\}; N,M \in \mathbb{Z};$$ 
	      repeats itself. The repeating texture is a good strategy as it lets us use lesser 
	      memory and faster loading times. In this particular case, I looked for some wooden 
	      floor-like textures and found this one. I had to write a shader to make this work 
	      and I will cover it later.
	      </p>
	    </section>
	  </li>
	  <li>
	    <section>
	      <h5>Walls</h5>
		<p>This object was the simplest to manufacture as this only needs 8 points and six quads
		to generate. I build the first iteration by using corners of a cuboid and that
		did a great job of containing the die object. However, it looked pretty weird 
		because of perspective projection which makes parallel lines non-parallel. The
		die behavior was not too pleasant around the edges and something better had to
		be done.
		</p>
		<p>
		I solved this problem by using the camera
		<a class="text-dark"
		href="http://www.lighthouse3d.com/tutorials/view-frustum-culling/clip-space-approach-extracting-the-planes">frustum</a> 
		o give me the exact boundaries and a more natural look and behavior that is acceptable. 
		The frustum is a collection of 6 planes where we can abandon the near and far planes and use 
		<a class="text-dark" href="http://www.songho.ca/math/index.html">plane-plane intersection</a>
		equations to figure out four extreme rays which project out of 
		the camera. Then we put two more planes right in front of the camera depending on the size 
		of the containment needed and intersect these four rays with these two planes at 8 points 
		to get the corners and use the corners to create six quads of containment.
		</p>
	    </section>
	  </li>
	</ul>
      </section>
    </div>
  </div>
</section>
<!-- /portfolio -->
